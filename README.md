# Linear-Search-Verilog

This project implements a **5-stage MIPS processor** (IF, ID, EX, MEM, WB) in Verilog, along with a **Python decoder** that translates MIPS assembly code into 32-bit binary to load the instruction memory (`instructions.mem`).

The main purpose is to demonstrate the operation of a MIPS pipeline using the **Linear Search algorithm** as a case study.

---

## Program Objective

Implement the **Linear Search algorithm** on an array stored in memory, where the processor:

1. Traverses the array in memory.
2. Compares each element with a target value.
3. Halts when the target value is found.
4. Writes the result (`1 = found`, `0 = not found`) to memory or a register.

### Benefits of this case study

- Visualize **real data dependencies** (`LW → BEQ`).  
- Observe **conditional and unconditional jumps**.  
- Validate **memory and base register management**.  
- Confirm the effectiveness of **forwarding and/or stalls** in the pipeline.

---

## MIPS Decoder (Python)

- Translates MIPS assembly into **32-bit binary instructions**.  
- Supports **R-type, I-type, and J-type instructions**.  
- Automatically generates `instructions.mem` with **exactly 1024 lines**.  
- Fills remaining lines with **NOPs (`00000000`)** for compatibility.  
- Ensures compatibility with `$readmemh` in Verilog.

---

## Main Files

- `Decoder.py` → MIPS assembly to binary translator.  
- `*.v` → Verilog files for the processor and testbench.  
- `instructions.mem` → Instruction memory generated by the decoder.  
- `pipeline.vcd` → Simulation output for **GTKWave**.



---

## Simulation
The simulation was run with:
python Decoder.py
Compile Verilog files:

iverilog -o pipeline.out *.v

##Run the simulation:
vvp pipeline.out

## Open results in GTKWave:
gtkwave pipeline.vcd

1. Generate instruction memory:

```bash
python Decoder.py

